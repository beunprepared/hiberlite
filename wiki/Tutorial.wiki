#summary hiberlite basics - creating DB, saving and loading objects.
#labels hiberlite,tutorial,documentation

= Introduction =

In this tutorial we will create an sqlite database, put a user object in it and then try to read that object back.

= Setup =
  * Download and install the library.
  * Include the header
{{{
#include "hiberlite.h"
}}}
  * Add the "-lhiberlite" flag to the linker options.
  * also link the sqlite library "-lsqlite3" .


= Source code  =
The complete and working [http://code.google.com/p/hiberlite/source/browse/trunk/sample.cpp source_code] for this tutorial is available in the svn repository.

= Basic usage =
To write a typical RDBMS application the following tasks should be implemented:
  # Open a database
  # Create database schema
  # Populate the tables with data
  # Read and/or modify that data
Hiberlite greatly reduces the implementation of each of these tasks.

== Creating a database ==
To open a database file simply write
{{{
       hiberlite::Database db;
       db.open("test.db");
}}}
_Database::open(std::string filename)_ opens a sqlite3 file. If it doesn't exist it will be created.
Another constructor is provided to simplify this:
{{{
       hiberlite::Database db("test.db");
}}}

== Creating database schema ==
In C++ You deal with classes and objects. You know *what* objects You want to store in the database. And hiberlite will figure out *how* to store that data.

=== Defining data model ===
First You must prepare the data classes for use with hiberlite.
Suppose we develop a social-network application. So we define a person as:
{{{
class Person{
public:
        string name;
        int age;
        vector<string> bio;
};
}}}
Now to let hiberlite know about the internal structure of this class, we add an access method and an export declaration:
{{{
class Person{
	friend class hiberlite::access;
	template<class Archive>
	void hibernate(Archive & ar)
	{
		ar & HIBERLITE_NVP(name);
		ar & HIBERLITE_NVP(age);
		ar & HIBERLITE_NVP(bio);
	}
public:
	string name;
	int age;
	vector<string> bio;
};
HIBERLITE_EXPORT_CLASS(Person)
}}}

Inside the _hibernate(Archive & ar)_ method we list all the data fields, that will be stored in the database. 
Macro _HIBERLITE_EXPORT_CLASS(Person)_ is invoked to declare a class name. For now just remember to invoke it once per class in your project. (Placing it in Person.cpp is a good idea)

At this point hiberlite is able to map the Person to a database.

== Creating tables ==
Database schema for hiberlite is simply a set of classes, that are stored in the database.  A programmer defines that set of classes, and hiberlite determines the needed tables and their columns.

Each instance of _hiberlite::Database_ maintains its own copy of the database schema (set of data classes). To insert a new class to that set, use _registerBeanClass_ template method:
{{{
db.registerBeanClass<Person>();
}}}

To store several 


= User-defined class =

First we define the class we plan to store in the database:

{{{
class MyClass{
        friend class hiberlite::access;
        template<class Archive>
        void hibernate(Archive & ar)
        {
                ar & HIBERLITE_NVP(a);
                ar & HIBERLITE_NVP(b);
                ar & HIBERLITE_NVP(vs);
        }
public:
        int a;
        double b;
        vector<string> vs;
};
HIBERLITE_EXPORT_CLASS(MyClass)
}}}


Note the _friend_ declaration and the _hibernate(...)_ template method - these two pieces of code are necessary for hiberlite to access the internal structure of the user-defined class.

*HIBERLITE_NVP* is a macro that creates a name-value pair with reference to its argument.

*HIBERLITE_EXPORT_CLASS()* defines the root table name for the class. More on this later.

= How is it stored =

hiberlite will use 2 tables to represent MyClass instances in the database:
{{{
CREATE TABLE MyClass 
(
    a INTEGER,
    b REAL,
    hiberlite_id INTEGER PRIMARY KEY AUTOINCREMENT
)
CREATE TABLE MyClass_vs_items 
(
    hiberlite_entry_indx INTEGER,
    hiberlite_id INTEGER PRIMARY KEY AUTOINCREMENT,
    hiberlite_parent_id INTEGER,
    item TEXT
)
}}}

Table *MyClass* is the root table for MyClass. It will contain one row per object. Columns *a* and *b* store values of the corresponding *int* and *double* fields.

_HIBERLITE_EXPORT_CLASS(MyClass)_ macro simply declares that instances of MyClass must be stored int the *MyClass* root table and its subtables.

*MyClass_vs_items* table is the "subtable" of *MyClass*. It is used to store elements of the *vs* vector: *hiberlite_parent_id* references the *hiberlite_id* of the root table, *hiberlite_entry_indx* - is the zero-index of the string element of the vector, and *item* is the value of that element.


= Creating a database =
We create a database file and some tables with
{{{
       hiberlite::Database db("sample.db");
       db.registerBeanClass<MyClass>();
       db.dropModel();
       db.createModel();
}}}
Every instance of the [Database] class maintains its own database schema, I call it the data model or simply model. _registerBeanClass<MyClass>()_ template method adds tables, needed to store MyClass objects (which are the *MyClass* and *MyClass_vs_items*) to that model.

_dropModel()_ calls "DROP TABLE IF EXISTS ..." for each table that presents in the model.

_createModel()_ calls "CREATE TABLE ..." for each table.

= Storing data =
After opening the database and (optionally) creating the tables we are ready to put some data in it.
Objects in the database are called *beans*.
To add a new bean to the database we call
{{{
hiberlite::bean_ptr<MyClass> p=db.copyBean(x);
}}}
_copyBean()_ creates an internal copy of its argument (using copy-constructor {{{new MyClass(x)}}}), saves it in the database and returns a [bean_ptr], pointing to that copy. bean_ptr is a smart-pointer, it will perform reference-counting and care about saving and destroying your bean when it is no longer in use. But the object will not disappear - it is stored in the database, and the only way to remove it is to call *bean_ptr<C>::destroy()*.
There are two other ways to create a bean in the database:
  * _bean_ptr<C> Database::createBean<C>()_ creates a bean using default constructor and returns a 
  * _bean_ptr<C> Database::manageBean<C>(C\* ptr)_ takes control over its argument and wraps it in the bean_ptr. You must not call _delete ptr;_ after calling _manageBean(ptr)_ - *bean_ptr* will do it when necessary.

= Loading data =
We load all the beans with
{{{
std::vector< hiberlite::bean_ptr<MyClass> > v=db.getAllBeans<MyClass>();
}}}
*bean_ptr<C>* is a smart pointer, but I forgot to mention that it is also a lazy pointer.
Beans itself are not loaded when with _getAllBeans<MyClass>()_ - only their primary keys.
To give user the access to the underlying object, *C\* bean_ptr<C>::operator->()* is overloaded. The object will be created and fetched from the database with the first use of _operator->_.